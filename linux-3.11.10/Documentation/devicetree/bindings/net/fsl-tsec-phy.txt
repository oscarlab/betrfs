* MDIO IO device

The MDIO is a bus to which the PHY devices are connected.  For each
device that exists on this bus, a child node should be created.  See
the definition of the PHY node in booting-without-of.txt for an example
of how to define a PHY.

Required properties:
  - reg : Offset and length of the register set for the device
  - compatible : Should define the compatible device type for the
    mdio.  Currently, this is most likely to be "fsl,gianfar-mdio"

Example:

	mdio@24520 {
		reg = <24520 20>;
		compatible = "fsl,gianfar-mdio";

		ethernet-phy@0 {
			......
		};
	};

* TBI Internal MDIO bus

As of this writing, every tsec is associated with an internal TBI PHY.
This PHY is accessed through the local MDIO bus.  These buses are defined
similarly to the mdio buses, except they are compatible with "fsl,gianfar-tbi".
The TBI PHYs underneath them are similar to normal PHYs, but the reg property
is considered instructive, rather than descriptive.  The reg property should
be chosen so it doesn't interfere with other PHYs on the bus.

* Gianfar-compatible ethernet nodes

Properties:

  - device_type : Should be "network"
  - model : Model of the device.  Can be "TSEC", "eTSEC", or "FEC"
  - compatible : Should be "gianfar"
  - reg : Offset and length of the register set for the device
  - local-mac-address : List of bytes representing the ethernet address of
    this controller
  - interrupts : For FEC devices, the first interrupt is the device's
    interrupt.  For TSEC and eTSEC devices, the first interrupt is
    transmit, the second is receive, and the third is error.
  - phy-handle : The phandle for the PHY connected to this ethernet
    controller.
  - fixed-link : <a b c d e> where a is emulated phy id - choose any,
    but unique to the all specified fixed-links, b is duplex - 0 half,
    1 full, c is link speed - d#10/d#100/d#1000, d is pause - 0 no
    pause, 1 pause, e is asym_pause - 0 no asym_pause, 1 asym_pause.
  - phy-connection-type : a string naming the controller/PHY interface type,
    i.e., "mii" (default), "rmii", "gmii", "rgmii", "rgmii-id", "sgmii",
    "tbi", or "rtbi".  This property is only really needed if the connection
    is of type "rgmii-id", as all other connection types are detected by
    hardware.
  - fsl,magic-packet : If present, indicates that the hardware supports
    waking up via magic packet.
  - bd-stash : If present, indicates that the hardware supports stashing
    buffer descriptors in the L2.
  - rx-stash-len : Denotes the number of bytes of a received buffer to stash
    in the L2.
  - rx-stash-idx : Denotes the index of the first byte from the received
    buffer to stash in the L2.

Example:
	ethernet@24000 {
		device_type = "network";
		model = "TSEC";
		compatible = "gianfar";
		reg = <0x24000 0x1000>;
		local-mac-address = [ 00 E0 0C 00 73 00 ];
		interrupts = <29 2 30 2 34 2>;
		interrupt-parent = <&mpic>;
		phy-handle = <&phy0>
	};

* Gianfar PTP clock nodes

General Properties:

  - compatible   Should be "fsl,etsec-ptp"
  - reg          Offset and length of the register set for the device
  - interrupts   There should be at least two interrupts. Some devices
                 have as many as four PTP related interrupts.

Clock Properties:

  - fsl,tclk-period  Timer reference clock period in nanoseconds.
  - fsl,tmr-prsc     Prescaler, divides the output clock.
  - fsl,tmr-add      Frequency compensation value.
  - fsl,tmr-fiper1   Fixed interval period pulse generator.
  - fsl,tmr-fiper2   Fixed interval period pulse generator.
  - fsl,max-adj      Maximum frequency adjustment in parts per billion.

  These properties set the operational parameters for the PTP
  clock. You must choose these carefully for the clock to work right.
  Here is how to figure good values:

  TimerOsc     = system clock               MHz
  tclk_period  = desired clock period       nanoseconds
  NominalFreq  = 1000 / tclk_period         MHz
  FreqDivRatio = TimerOsc / NominalFreq     (must be greater that 1.0)
  tmr_add      = ceil(2^32 / FreqDivRatio)
  OutputClock  = NominalFreq / tmr_prsc     MHz
  PulseWidth   = 1 / OutputClock            microseconds
  FiperFreq1   = desired frequency in Hz
  FiperDiv1    = 1000000 * OutputClock / FiperFreq1
  tmr_fiper1   = tmr_prsc * tclk_period * FiperDiv1 - tclk_period
  max_adj      = 1000000000 * (FreqDivRatio - 1.0) - 1

  The calculation for tmr_fiper2 is the same as for tmr_fiper1. The
  driver expects that tmr_fiper1 will be correctly set to produce a 1
  Pulse Per Second (PPS) signal, since this will be offered to the PPS
  subsystem to synchronize the Linux clock.

Example:

	ptp_clock@24E00 {
		compatible = "fsl,etsec-ptp";
		reg = <0x24E00 0xB0>;
		interrupts = <12 0x8 13 0x8>;
		interrupt-parent = < &ipic >;
		fsl,tclk-period = <10>;
		fsl,tmr-prsc    = <100>;
		fsl,tmr-add     = <0x999999A4>;
		fsl,tmr-fiper1  = <0x3B9AC9F6>;
		fsl,tmr-fiper2  = <0x00018696>;
		fsl,max-adj     = <659999998>;
	};
